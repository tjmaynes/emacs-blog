#+TITLE: Refactoring Try...Catch
#+DATE: <2020-01-15, Wed>
#+DESCRIPTION: In this blog post, we'll be refactoring a function that isn't quite working the way we are expecting the function to work.

Recently, I've been asking myself, "How can this function fail?" This question has led to a different style of programming that I've chosen to utilize in various problem solving scenarios (mostly around integrations with external systems). Let's take a look at the following function written in [[https://kotlinlang.org/docs/reference/][Kotlin]]:

#+begin_src kotlin
fun add1(x: Int): Int = x + 1
#+end_src

This function is pretty straightforward, but let's say what it's intent is in a sentence: "Function add1 takes an Integer element 'x' and returns the Integer plus one." We can guarentee that every time this function is called with any integer value it will return the same result.

#+begin_src kotlin
assertEquals(1, add1(0))
assertEquals(2, add1(1))
assertEquals(3, add1(2))
...
...
#+end_src

From a functional programming perspective, this function would be considered [[https://en.wikipedia.org/wiki/Pure_functionXS][pure]]. A pure function is a function that has the same return value for the same input value and does not contain any side effects. The guarentees of a pure function enable software developers to write safer software. But what happens when you need to introduce a side effect into your application. Side effects are not necessarily a bad thing, it's actually great thing that they occur; it means your program is useful. Useful features of an application, may include (but not limited to):

- User input
- Talking to a database or external service
- Receiving command-line arguments
- Reading environment variables

While usefulness has its rewards, it also comes at a cost. Anytime we introduce a side effect into our software, we introduce additional ways for our application to fail. Let's take a look at what happens when we write a function that attempts to fetch a thing (T) from a database.

#+begin_src kotlin
fun <T> getById(id: String): T =
  databaseDriver.getById(id)
#+end_src

This simple function takes an id and returns a thing that is fetched from a database using a database driver. But, what happens when the thing is not in the database? If the thing is not in the database, then our function will not return our thing. Maybe we should rethink our approach to this function.

#+begin_src kotlin
fun <T> getById(id: String): T? =
  databaseDriver.getById(id) ?: null
#+end_src

There! That's it! We changed our return type to return an optional thing. This is convenient for us because that let's the caller of this function decide what to do when a thing is not found in our database.

But, what happens if we can't find our thing because we were able to connect to our database?

Let's assume our getById function provided by databaseDriver throws an exception. Unfortunately we have not managed what happens when our internal dependency throws an exception. A common pattern for dealing with functions that throw, is to use a Try...catch.

Let's rewrite our code to utilize the Try...catch pattern.

#+begin_src kotlin
fun <T> getById(id: String): T? =
  return try {
    databaseDriver.getById(id) ?: null
  } catch (e: Exception) {
    null
  }
#+end_src

#+begin_src kotlin
fun <T> getById(id: String): Either<Exception, Option<T>> =
  Either.catch { repository.getById(id).toOption() }
#+end_src
